# TorusDEC a class simple 3D grid with basic exterior calculus operations.
#
# SYNTAX
#
#   obj = TorusDEC(sizex,sizey,sizez,resx,resy,resz)
#   obj = TorusDEC(sizex,sizey,sizez,res)
#   classdef MyPDEProblem < TorusDEC
#
# DESCRIPTION
#
#   TorusDEC is a handle class that an instance is a 3D grid with periodic
#   boundaries in x,y,z direction, i.e. a 3-torus. DEC stands for "Discrete
#   Exterior Calculus", a set of operations including exterior derivatives,
#   codifferentials.
#
#   obj = TorusDEC(sizex,sizey,sizez,resx,resy,resz) creates an instance
#   obj, a 3D grid with size sizex, sizey, sizez and number of divisions
#   resx,resy,resz in each dimension.
#
#   obj = TorusDEC creates a default empty instance.
#
#   obj = TorusDEC(obj2) copies obj2 to obj.
#
#   obj = TorusDEC(sizex,sizey,sizez,res) creates a grid with size
#   sizex,sizey,sizez so that edge lengths dx,dy,dz are equal (cubic
#   lattice).  Input res specifies the number of grid points in the longest
#   dimension.
#
#   classdef MyPDEProblem < TorusDEC defines MyPDEProblem as a subclass of
#   TorusDEC. MyPDEProblem inherits all methods and members of TorusDEC.
#
#
# CLASS MEMBERS
#
#   sizex,sizey,sizez - length in each dimension.
#     resx, resy,resz - number of divisions in each dimension.
#          px, py, pz - positions.  Each of px, py, pz is a 3D array
#                       carrying x,y,z coordinate of each grid vertex.
#                       px ranges from 0 to sizex, and similarly for py,pz.
#          dx, dy, dz - edge lengths in each dimension.
#          ix, iy, iz - convenient 1D arrays 1:resx, 1:resy, 1:resz.
#       iix, iiy, iiz - convenient 3D arrays generated by ndgrid(ix,iy,iz).
#
# METHODS
#
#  Suppose obj is an instance of TorusDEC.
#
#  Exterior derivatives:
#
#  [vx,vy,vz] = obj.DerivativeOfFunction(f)
#     For a function f compute the 1-form df.
#     f is a 3D array representing a scalar function on the grid. vx,vy,vz
#     is the 1-form df integrated along edges. vx corresonds to edge
#     (i,j,k)->(i+1,j,k) and so on.
#
#  [wx,wy,wz] = obj.DerivativeOfOneForm(vx,vy,vz)
#     For a 1-form v compute the 2-form dv.
#
#  f = obj.DerivativeOfTwoForm(wx,wy,wz)
#     For a 2-form w compute the 3-form dw.
#
#  Codifferentials:
#
#  f = obj.Div(vx,vy,vz)
#     For a 1-form v compute the function *d*v.
#
#  Sharp Operator:
#
#  [ux,uy,uz] = obj.Sharp(vx,vy,vz)
#       For a 1-form v compute the corresponding vector field v^sharp by
#       averaging to vertices
#
#  [ux,uy,uz] = obj.StaggeredSharp(vx,vy,vz)
#       For a 1-form v compute the corresponding vector field v^sharp as
#       a staggered vector field living on edges
#
#  Poisson Solve:
#
#  u = obj.PoissonSolve(f)
#       solves the Poisson equation L u = f, where L is the Laplacian on
#       the 3-torus (negative semidefinite convension).
#       u and f has zero mean.
#
type TorusDEC
    px::Array{Float64,3}; py::Array{Float64,3}; pz::Array{Float64,3}          # coordinates of grid points
    ix::UnitRange{Int}; iy::UnitRange{Int}; iz::UnitRange{Int}          # 1D index array
    iix::Array{Int, 3}; iiy::Array{Int, 3}; iiz::Array{Int, 3}         # 3D index array
    dx::Float64; dy::Float64; dz::Float64          # edge length
    sizex::Int; sizey::Int; sizez::Int # size of grid
    resx::Int; resy::Int; resz::Int    # number of grid points in each dimension
    fac::Array{Float64,3}
    velocity::Array{Point3f0,3}

    function TorusDEC(vol_size::NTuple{3}, vol_res::NTuple{3})
        obj = new()
        obj.sizex,obj.sizey, obj.sizez = vol_size
        obj.resx = round(Int, vol_res[1])
        obj.resy = round(Int, vol_res[2])
        obj.resz = round(Int, vol_res[3])
        obj.dx = obj.sizex/obj.resx;
        obj.dy = obj.sizey/obj.resy;
        obj.dz = obj.sizez/obj.resz;
        obj.ix = 1:obj.resx;
        obj.iy = 1:obj.resy;
        obj.iz = 1:obj.resz;
        obj.iix,obj.iiy,obj.iiz = ndgrid(obj.ix,obj.iy,obj.iz)
        obj.px = (obj.iix-1)*obj.dx;
        obj.py = (obj.iiy-1)*obj.dy;
        obj.pz = (obj.iiz-1)*obj.dz;
        sx = sin(pi*(obj.iix-1)/obj.resx)/obj.dx
        sy = sin(pi*(obj.iiy-1)/obj.resy)/obj.dy
        sz = sin(pi*(obj.iiz-1)/obj.resz)/obj.dz
        denom = sx.^2 + sy.^2 + sz.^2
        obj.fac = -0.25./denom
        obj.fac[1,1,1] = 0.0
        obj.velocity = Array(Point3f0, size(obj.px))
        return obj
    end
    function TorusDEC(varargin...)
        n = length(varargin)
        if n == 0 # empty instance
            return
        elseif n == 4
            mi = findmax(varargin[1:3])
            ratio = [varargin[1:3]...]./varargin[mi]
            res = round(ratio*varargin[4])
            return TorusDEC(varargin[1:3],res[1],res[2],res[3])
        end
        error(
            "TorusDEC:badinput
            Wrong number of inputs."
        )
    end
end


"""
 For a function f compute the 1-form df
"""
function DerivativeOfFunction{T}(obj::TorusDEC, f::Array{T, 3})
    v = Array(Point3f0, size(f))
    for z=obj.iz, y=obj.iy, x=obj.ix
        ixp = mod(x, obj.resx) + 1
        iyp = mod(y, obj.resy) + 1
        izp = mod(z, obj.resz) + 1
        ff = f[x,y,z]
        v[x,y,z] = Point3f0(
            f[ixp,y,z] - ff,
            f[x,iyp,z] - ff,
            f[x,y,izp] - ff,
        )
    end
    v
end

"""
 For a 1-form v compute the 2-form dv
"""
function DerivativeOfOneForm(obj::TorusDEC, velocity)
    w = similar(velocity)
    @inbounds for z=obj.iz, y=obj.iy, x=obj.ix
        ixp = mod(x, obj.resx) + 1
        iyp = mod(y, obj.resy) + 1
        izp = mod(z, obj.resz) + 1

        x1 = velocity[x, y, izp][1]
        y1 = velocity[ixp, y, z][2]
        z1 = velocity[x, iyp, z][3]

        x2 = velocity[x, iyp, z][1]
        y2 = velocity[x, y, izp][2]
        z2 = velocity[ixp, y, z][3]

        v = velocity[x,y,z]
        w[x,y,z] = Point3f0(
            v[1] - x1 + x2 - v[1],
            v[2] - y1 + y2 - v[2],
            v[3] - z1 + z2 - v[3]
        )
    end
    w
end

"""
 For a 2-form w compute the 3-form dw
"""
function DerivativeOfTwoForm(obj::TorusDEC, w)
    f = Array(Float64, size(w))
    @inbounds for z=obj.iz, y=obj.iy, x=obj.ix
        ixp = mod(x, obj.resx) + 1
        iyp = mod(y, obj.resy) + 1
        izp = mod(z, obj.resz) + 1
        x = w[ixp, y, z][1]
        y = w[x, iyp, z][2]
        z = w[x, y, izp][3]
        wi = w[x,y,z]
        ff =  x - wi[1]
        ff += y - wi[2]
        ff += z - wi[3]
        f[x,y,z] = ff
    end
    f
end

"""
For a 1-form v compute the function `*d*v`
"""
function Div(obj::TorusDEC, velocity)
    f = Array(Float64, size(velocity))
    @inbounds for z=obj.iz, y=obj.iy, x=obj.ix
        ixm = mod(x-2, obj.resx) + 1
        iym = mod(y-2, obj.resy) + 1
        izm = mod(z-2, obj.resz) + 1
        _x = velocity[ixm, y, z][1]
        _y = velocity[x, iym, z][2]
        _z = velocity[x, y, izm][3]
        v = velocity[x,y,z]
        ff =  (v[1] - _x) / obj.dx^2
        ff += (v[2] - _y) / obj.dy^2
        ff += (v[3] - _z) / obj.dz^2
        f[x,y,z] = ff
    end
    f
end

"""
 For a 1-form v compute the corresponding vector field v^sharp by
 averaging to vertices
"""

function Sharp(obj::TorusDEC, velocity)
    d = 1f0/Point3f0(obj.dx, obj.dy, obj.dz)
    u = similar(velocity)
    @inbounds for z=obj.iz, y=obj.iy, x=obj.ix
        ixm = mod(x-2, obj.resx) + 1
        iym = mod(y-2, obj.resy) + 1
        izm = mod(z-2, obj.resz) + 1
        x = velocity[ixm, y, z][1]
        y = velocity[x, iym, z][2]
        z = velocity[x, y, izm][3]
        u[x,y,z] = 0.5*Point3f0(x,y,z)+velocity[x,y,z].*d
    end
    u
end

"""
 For a 1-form v compute the corresponding vector field `v^sharp` as
 a staggered vector field living on edges
"""
function StaggeredSharp(obj::TorusDEC, velocity)
    d = 1f0/Point3f0(obj.dx, obj.dy, obj.dz)
    @inbounds for i in eachindex(velocity)
        velocity[i] = velocity[i] .* d
    end
    velocity
end

"""
PoissonSolve by Spectral method
"""
function PoissonSolve(obj, f)
    fc = fft(f)
    @inbounds for i=1:length(obj.fac)
        fc[i] = fc[i] .* obj.fac[i]
    end
    ifft!(fc)
    fc
end
